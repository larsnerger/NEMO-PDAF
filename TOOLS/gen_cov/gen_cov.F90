! $Id: generate_covar.F90 1604 2016-05-30 06:42:16Z lnerger $
!BOP
!Modified by QT 2017-12-12 ---- for AWI-CM
!Modified again by TQ 2017-12-19
!Modified by YC 2022-06-17

! !Program: generate_covar --- Compute covariance matrix from state trajectory
PROGRAM generate_covar
   ! !DESCRIPTION:
   ! This programm to computes a covariance matrix from a
   ! model trajectory of NEMO. The matrix is decomposed in
   ! EOFs and stored in form of eigenvalues and eigenvectors.
   !
   ! The matrix is generated by a singular value decomposition
   ! of the perturbation matrix of a long state trajectory
   ! about its long time mean.
   !
   ! In this version:
   ! 1) the state vector is structured (z(ssh) u v w t s)^T, where SSH is put on
   ! top position;
   ! 2) output frequency is every 5th day;
   ! 3) Only one output file, including the running mean, singular values and singular vectors

   ! !USES:
   ! use mod_io_pdaf, only: get_var_dims, get_steps, read_state_mv, write_state
   use mod_kind_pdaf, only: pdp
   use mod_statevector_pdaf, only: state_field, init_sfields
   use mod_io_pdaf, only: write_state
   use pdaf_interfaces_module, only: PDAF_eofcovar
   implicit none

   !EOP
   integer :: i ! counter
   integer :: n2d ! size of 2d field
   integer :: n3d ! size of 3d field
   integer :: nfields ! number of variables
   integer :: dim_state ! dimension of state vector
   integer :: steps ! total timesteps from input files
   integer :: maxsteps ! maximum time steps in a single file
   integer :: maxtimes ! maximum allowing time steps
   integer :: hwindow ! Half time window for running mean (2*irange+1)

   type(state_field), allocatable :: sfields(:) ! information of state vector

   real(pdp), allocatable :: states(:, :) ! state vector
   real(pdp), allocatable :: meanstate(:) ! time mean state vector
   real(pdp), allocatable :: run_meanstate(:, :) ! running mean state vector

   integer :: remove_mean
   integer :: do_mv  ! Set do_mv=1 to activate normalization; 0 to run without normalization
   integer :: status ! status flag
   integer :: rank
   real(pdp), allocatable :: svals(:) ! field of singular values
   real(pdp), allocatable :: svdu(:, :) ! left singular vectors
   real(pdp), allocatable :: stddev(:) ! stddev of field

   real(pdp) :: limit  ! lower limit for singular values

   namelist /cov_options/ maxtimes, do_mv, remove_mean, limit, hwindow
   open(unit=20, file='namelist_gen_cov.pdaf')
   ! get the number of experiments and whether date splitting is on 
   read(unit=20, nml=cov_options)
   rewind(20)

   ! ************************************************
   ! *** Init                                     ***
   ! ************************************************

   write (*,'(10x,a)') '*******************************************'
   write (*,'(10x,a)') '*             GENERATE_COVAR              *'
   write (*,'(10x,a)') '*                                         *'
   write (*,'(10x,a)') '*    Compute covariance matrix and mean   *'
   write (*,'(10x,a)') '*     state from a sequence of states.    *'
   write (*,'(10x,a)') '*                                         *'
   write (*,'(10x,a)') '*   Write covar matrix as scaled eigen-   *'
   write (*,'(10x,a)') '*    vectors and singular values into     *'
   write (*,'(10x,a)') '*              NetCDF file                *'
   write (*,'(10x,a/)') '*******************************************'

   ! initialise information about state vector
   call init_sfields(sfields, nfields, n2d, n3d)
   close(20)

   call get_dimensions(sfields, nfields, n2d, n3d, maxtimes, steps, maxsteps, dim_state)

   ! ****************************
   ! *** Read trajectory data ***
   ! ****************************
   ALLOCATE(states(dim_state, maxtimes))
   call read_statevector(sfields, nfields, steps, maxsteps, states)

   ! **********************************
   ! *** Compute running mean state ***
   ! **********************************

   WRITE (*,'(1x,a,i5,a)') 'Compute running mean over', maxtimes,' snapshots'
   ALLOCATE(meanstate(dim_state))
   ALLOCATE(run_meanstate(dim_state, maxtimes))

   call compute_running_mean(maxtimes, hwindow, meanstate, run_meanstate)

   ! get residual
   states = states - run_meanstate

   ! *********************************************************
   ! *** Singular value decomposition of covariance matrix ***
   ! ***                                                   ***
   ! *** The covariance matrix is given by the state       ***
   ! *** sequences X of k states as                        ***
   ! ***          -1    _     _ T        T                 ***
   ! *** P = (k-1)   (X-X) (X-X)  = U L U  (EVP)           ***
   ! ***                                                   ***
   ! *** Thus we compute the singular value decomposition  ***
   ! ***     _        T            -1    2  T              ***
   ! ***   X-X = U S V ;  P = (k-1)   U S  U               ***
   ! ***                                                   ***
   ! ***                         -1/2                      ***
   ! *** and we store U and (k-1)     S in a NetCDF file.  ***
   ! *********************************************************

   WRITE (*,'(/1x,a)') '------- Compute covariance matrix decomposition -------------'

   ! PDAF_eofcovar should compute and subtract the mean state from Trajectory
   ! before decomposition. Afterwards, it's added again.


   ! Allocate arrays for singular values and vectors
   ALLOCATE(svals(maxtimes))
   ALLOCATE(svdU(dim_state, maxtimes))
   allocate(stddev(nfields))
   ! Call routine generating matrix decomposition
   CALL PDAF_eofcovar(dim_state, maxtimes, nfields, sfields(:)%dim, sfields(:)%off, &
      remove_mean, do_mv, states, stddev, svals, svdU, meanstate, 1, status)

   if (status /= 0) then
      write (*, '(/1x,a)') '--------- Error in PDAF_eofcovar -----'
      STOP
   end if

   ! *** determine rank to write ***
   getlimit: do i = 1, maxtimes
      if (svals(i) >= limit) then
         rank = i
      else
         exit getlimit
      end if
   end do getlimit

   if (rank < maxtimes) then
      write (*,'(1x,a,i6,a,es10.2)') &
      'use maximum of ', rank, ' eigenvectors due to eigenvalue-limit of ',limit
   end if
   if (rank == maxtimes) then
      rank = maxtimes - 1
      write (*,'(5x,a,i4)') '++ reset rank to ',rank
   end if

   write (*,'(5x,a)') 'singular values: '
   do i = 1, rank
      write (*, '(10x, i4, es12.3)') i, svals(i)
   end do

   call write_state('cov.nc', sfields(:)%variable, sfields(:)%ndims, &
                    sfields(:)%off, n2d, n3d, dim_state, maxtimes, nfields, &
                    svals, svdu, rank, run_meanstate, do_mv)
   ! ********************
   ! *** Finishing up ***
   ! ********************

   DEALLOCATE(states, meanstate)
   DEALLOCATE(svals, svdU)

   WRITE (*,'(/1x,a/)') '------- END -------------'

contains
   subroutine get_dimensions(sfields, nfields, &
                             n2d, n3d, maxtimes, steps, maxsteps, dim_state)
      integer, intent(in) :: nfields ! number of variables
      type(state_field), intent(in) :: sfields(nfields)
      integer, intent(in) :: n2d ! size of 2d field
      integer, intent(in) :: n3d ! size of 3d field
      integer, intent(inout) :: maxtimes ! maximum allowing time steps
      integer, intent(out) :: steps ! total timesteps from input files
      integer, intent(out) :: dim_state ! dimension of state vector
      integer,intent(out) :: maxsteps  ! maximum time steps in a single file

      ! total length of the state vector
      dim_state = sfields(nfields)%dim + sfields(nfields)%off
      ! derive the total number of steps from input files
      call get_total_steps_in_files(sfields, nfields, maxtimes, steps, maxsteps)

      print *, 'total steps:', steps
      ! write dimensions
      write (*,'(/1x,a)') 'Dimensions of experiment:'
      write (*,'(10x,1x,a3,i12)') 'number of 2D grid points', n2d
      write (*,'(10x,1x,a3,i12)') 'number of 3D grid points', n3d
      write (*,'(5x,2x,a,i12)') 'nfields', nfields
      write (*,'(11x,a,i10)')   'time steps', steps
      write (*,'(5x,a,i12)') 'dim_state', dim_state

      if (steps < maxtimes) then
         write (*,'(1x,a)') '!! Number of available time slices is smaller than maxtimes - resetting!'
         maxtimes = steps
      end if
      write (*,'(13x,a8,i10)') 'maxtimes', maxtimes
   end subroutine get_dimensions

   subroutine get_total_steps_in_files(sfields, nfields, maxtimes, steps, maxsteps)
      use mod_io_pdaf, only: get_steps
      use mod_statevector_pdaf, only: get_filename
      integer, intent(in) :: nfields
      type(state_field), intent(in) :: sfields(nfields)
      integer, intent(in) :: maxtimes
      integer, intent(out) :: steps  ! minimum time steps across all model fields
      integer, intent(out) :: maxsteps  ! maximum time steps in a single file

      integer :: i  ! counter
      character(100) :: filename  ! filename for reading
      logical :: do_exit  ! exit from filename iteration
      logical :: do_init  ! starting from the first filename
      integer :: field_steps ! total time steps in each model field
      integer :: file_steps ! time steps in each file

      

      ! get total time steps of a file
      steps = maxtimes
      maxsteps = 0
      do i = 1, nfields
         field_steps = 0
         do_init = .true.
         do_exit = .false.
         readfile: do
            filename = get_filename(sfields(i), do_init, do_exit)
            do_init = .false.
            if (do_exit) exit readfile
            file_steps = get_steps(trim(filename))
            field_steps = field_steps + file_steps
            maxsteps = max(maxsteps, file_steps)
         end do readfile
         steps = min(steps, field_steps)
      end do

   end subroutine get_total_steps_in_files

   subroutine read_statevector(sfields, nfields, steps, maxsteps, states)
      use mod_statevector_pdaf, only: state_field, get_filename
      use mod_io_pdaf, only: get_var_dims, get_steps, read_state_mv
      integer, intent(in) :: nfields
      type(state_field), intent(in) :: sfields(nfields)
      integer, intent(in) :: steps
      integer, intent(in) :: maxsteps
      real(pdp), intent(inout) :: states(:, :)

      ! local variables
      integer :: i, it  ! counter
      character(100) :: filename  ! filename for reading
      logical :: do_exit  ! exit from filename iteration
      logical :: do_init  ! starting from the first filename

      integer :: file_steps  ! cumulative steps in previous files
      integer :: off  ! offset in state vectors
      integer :: dim  ! size of field
      integer :: nx, ny, nlvls  ! spatial dimension of the field
      integer :: nt  ! number of time steps read from a single file

      real(pdp), allocatable :: field(:, :, :, :)  ! model field from output file
      

      write (*,'(/1x,a)') '------- Read trajectory -------------'
      
      ! Initialize state
      states = 0.0
      call get_var_dims(trim(get_filename(sfields(1), .true.)), nlvls, ny, nx)
      allocate(field(nx, ny, nlvls, maxsteps))

      ! loop over fields at the same time step
      do i = 1, nfields
         do_init = .true.
         do_exit = .false.
         file_steps = 0

         readfile: do
            filename = get_filename(sfields(i), do_init, do_exit)
            do_init = .false.
            if (do_exit) exit readfile

            call read_state_mv(trim(filename), trim(sfields(i)%variable), &
                               sfields(i)%ndims, field)

            ! convert field to state
            nt = get_steps(trim(filename))
            off = sfields(i)%off
            dim = sfields(i)%dim
            do it = 1, nt
               if (it + file_steps > steps) exit readfile
               if (sfields(i)%ndims == 3) then
                  states(1 + off: dim + off, it + file_steps) = reshape(field(:, :, :, it), [sfields(i)%dim])
               else
                  states(1 + off: dim + off, it + file_steps) = reshape(field(:, :, 1, it), [sfields(i)%dim])
               end if
            end do
            file_steps = file_steps + nt
         end do readfile

      end do
      deallocate(field)
   end subroutine read_statevector

   subroutine compute_running_mean(maxtimes, hwindow, meanstate, run_meanstate)
      integer, intent(in) :: maxtimes ! max number of time steps
      integer, intent(in) :: hwindow ! half the window of running mean
      real(pdp), intent(inout) :: meanstate(:) ! mean
      real(pdp), intent(inout) :: run_meanstate(:, :) ! running mean

      integer :: i, j ! counter

      do i = 1, maxtimes
         meanstate = 0.0

         if (i > hwindow .and. i <= (maxtimes - hwindow)) then
            do j = i - hwindow, i + hwindow
               meanstate = meanstate + states (:, j)
            end do

         else if (i <= hwindow) then
               do j = 1, i + hwindow
                  meanstate = meanstate + states (:, j)
               end do
               do j = maxtimes - hwindow +i, maxtimes
                  meanstate = meanstate + states (:, j)
               end do

         else if (i > maxtimes - hwindow) then
            do j = i - hwindow, maxtimes
               meanstate = meanstate + states (:, j)
            end do
            do j = 1, i + hwindow - maxtimes
               meanstate = meanstate + states (:, j)
            end do
         end if

         meanstate = meanstate / (2 * hwindow + 1)
         run_meanstate (:, i) = meanstate
      end do
   end subroutine compute_running_mean
END PROGRAM generate_covar
